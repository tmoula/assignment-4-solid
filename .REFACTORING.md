# Refactoring Report: SOLID Principles

## Project
**Library Management Refactor**

**Goal:** Move a monolithic `LibraryService` toward SOLID design using Spring and Spring Data JPA.  
**Result:** ✅ Focused services ✅ Highly testable ✅ OCP/DIP applied ✅ Clear separation of responsibilities  

---

## Single Responsibility Principle (SRP)

### Violation
The original `LibraryService` class had multiple responsibilities:
- Book operations (checkout, return, availability)
- Member operations (checkout counts)
- Notifications
- Search operations
- Reporting

Changes to any of these features required modifying the same class.

### Our Solution
We extracted focused services:
- `BookService` – book operations (checkout, return)
- `MemberService` – member operations and counters
- `NotificationService` – notifications (email, SMS, mock)
- `BookSearchService` – search functionality
- `ReportGenerator` & implementations – report generation strategies

### Code Example

**Before:**
```java
public class LibraryService {
    public String checkoutBook(String isbn, String memberEmail) {
        // Find book, member, check availability, update state
        // Send notifications
        // Calculate limits
    }
}

@Service
public class BookService {
    private final BookRepository bookRepository;

    public void checkoutBook(Book book, Member member, int loanPeriodDays) {
        book.setCheckedOutBy(member.getEmail());
        book.setDueDate(LocalDate.now().plusDays(loanPeriodDays));
        book.setAvailable(false);
        bookRepository.save(book);
    }
}

@Service
public class MemberService {
    private final MemberRepository memberRepository;

    public void incrementCheckoutCount(Member member) {
        member.setBooksCheckedOut(member.getBooksCheckedOut() + 1);
        memberRepository.save(member);
    }
}

Why This Is Better

Each service has one reason to change

Easier to test and maintain

Clearer code and reusable components

Open–Closed Principle (OCP)
Violation

Membership rules were hard-coded with if-else statements:
if (member.getMembershipType() == REGULAR) { ... }
else if (member.getMembershipType() == PREMIUM) { ... }

Adding a new membership type required modifying the same code.

Our Solution

Implemented the Strategy Pattern via a CheckoutPolicy interface:

RegularCheckoutPolicy, PremiumCheckoutPolicy, StudentCheckoutPolicy

CheckoutPolicyFactory selects the correct strategy

Code Example

After:
CheckoutPolicy policy = checkoutPolicyFactory.getPolicyFor(member.getMembershipType());

if (!policy.canCheckout(member)) {
    return "Member has reached checkout limit";
}

int loanPeriodDays = policy.getLoanPeriodDays();
bookService.checkoutBook(book, member, loanPeriodDays);

Why This Is Better

New membership types added without changing existing code

Centralized and testable policy logic

Follows OCP by extending behavior through new strategies

Conclusion

The refactored design demonstrates all five SOLID principles:

Easier to understand – focused, meaningful classes

Easier to test – mockable and isolated components

Easier to extend – add new policies or reports without rewrites

Easier to maintain – localized changes and clear dependencies

Flexible – abstractions allow seamless swapping of implementations

# Refactoring Report: SOLID Principles

**Project:** assignment-4-solid
**Goal:** Move a monolithic `LibraryService` toward SOLID design with Spring Data JPA.
**Result:** ✅ All tests passing, ✅ H2 integration test running, ✅ **80%+** service-layer coverage (from ~62%).

---

## Overview of What Changed

We decomposed the original `LibraryService` and introduced strategies, registries, and a facade. Final structure:

- `edu.trincoll.service`
- `BookSearchService` ← focused search APIs
- `SearchFacade` ← single entrypoint that routes to `BookSearchService`
- `MemberService` ← member counters & lookups
- `LateFeeCalculator` + `Regular/Premium/StudentLateFeeCalculator` + `LateFeeCalculatorFactory`
- `report/`
- `ReportGenerator` (interface)
- `AvailabilityReportGenerator`, `OverdueReportGenerator`, `MembersReportGenerator`
- `ReportRegistry` (type→strategy selector)
- `LibraryService` (kept legacy behavior for compatibility)
- `LibraryFacade` (simplified top-level API)

---

## Single Responsibility Principle (SRP)

### Violation
The original `LibraryService` had multiple responsibilities:
- Book operations (checkout/return)
- Member counters
- Notifications
- Search logic
- Report generation

### Our Solution
We extracted focused services:
- `BookSearchService` – handles searching
- `SearchFacade` – routes search requests
- `MemberService` – handles member state
- Report strategies – each handles one report type

### Code Example

**Before:**
```java
public List<Book> searchBooks(String searchTerm, String searchType) {
if ("title".equalsIgnoreCase(searchType)) {
return bookRepository.findByTitleContainingIgnoreCase(searchTerm);
} else if ("author".equalsIgnoreCase(searchType)) {
return bookRepository.findByAuthor(searchTerm);
} else if ("isbn".equalsIgnoreCase(searchType)) {
return bookRepository.findByIsbn(searchTerm).map(List::of).orElse(List.of());
} else {
throw new IllegalArgumentException("Invalid search type");
}
}
```
**After:**
````
@Service
public class BookSearchService {
private final BookRepository repo;
public List<Book> searchByTitle(String t) { return repo.findByTitleContainingIgnoreCase(t); }
public List<Book> searchByAuthor(String a) { return repo.findByAuthor(a); }
public Optional<Book> searchByIsbn(String i) { return repo.findByIsbn(i); }
}

@Component
public class SearchFacade {
private final BookSearchService svc;
public List<Book> search(String term, String type) {
if (type == null) throw new IllegalArgumentException("Invalid search type");
return switch (type.toLowerCase()) {
case "title" -> svc.searchByTitle(term);
case "author" -> svc.searchByAuthor(term);
case "isbn" -> svc.searchByIsbn(term).map(List::of).orElse(List.of());
default -> throw new IllegalArgumentException("Invalid search type");
};
}
}
````

### Why This Is Better

- One reason to change per class.

- Easier to mock and test.

- LibraryService delegates without complex branching.

- Open–Closed Principle (OCP) & Liskov Substitution Principle (LSP)
- Violation LibraryService.generateReport() used if/else blocks to handle each report type. Adding a new type required editing this method.

### Our Solution

We introduced a Strategy pattern with a Registry:

- ReportGenerator interface

- AvailabilityReportGenerator, OverdueReportGenerator, MembersReportGenerator

- ReportRegistry for selecting the right generator

**Before:**
````
public String generateReport(String reportType) {
if ("overdue".equalsIgnoreCase(reportType)) { ... }
else if ("available".equalsIgnoreCase(reportType)) { ... }
else if ("members".equalsIgnoreCase(reportType)) { ... }
else throw new IllegalArgumentException("Invalid report type");
}
````
**After**:

````
package edu.trincoll.service.report;

import org.springframework.stereotype.Component;

import java.util.Map;
import java.util.stream.Collectors;

@Component
public class ReportRegistry {
private final Map<String, ReportGenerator> byType;

public ReportRegistry(java.util.List<ReportGenerator> generators) {
this.byType = generators.stream()
.collect(Collectors.toMap(g -> g.getType().toLowerCase(), g -> g));
}

public ReportGenerator get(String type) {
ReportGenerator gen = byType.get(type.toLowerCase());
if (gen == null) throw new IllegalArgumentException("Invalid report type");
return gen;
}
}


````

### Why This Is Better

- OCP: add new reports by creating a class, not modifying existing code.

- LSP: all generators are interchangeable via ReportGenerator.

- Interface Segregation Principle (ISP) Violation LibraryService forced clients to depend on unused methods.

### Our Solution
- Introduced SearchFacade so clients can depend only on what they need.

- LibraryFacade provides a simple entrypoint for controllers.

### Why This Is Better

- Smaller contracts.

- Clean mocking.

- Looser coupling.

- Dependency Inversion Principle (DIP)

### Violation
- High-level logic depended on concrete details (e.g., System.out.println for notifications, hard-coded branches).

### Our Solution
- Depend on interfaces (ReportGenerator, LateFeeCalculator).
- Use constructor injection.
- ReportRegistry and LateFeeCalculatorFactory provide abstraction for selection.

### Why This Is Better

- Easier to extend and test.
- Cleaner architecture.

### Strategy Pattern for Late Fees
We added:

- LateFeeCalculator interface

- RegularLateFeeCalculator, PremiumLateFeeCalculator, StudentLateFeeCalculator

- LateFeeCalculatorFactory to select the right strategy.

- This eliminated hard-coded if/else membership logic.

### Facade Pattern
``````
@Service
public class LibraryFacade {
private final SearchFacade searchFacade;
private final LibraryService libraryService;

public List<Book> search(String term, String type) {
return searchFacade.search(term, type);
}

public String generateReport(String type) {
return libraryService.generateReport(type);
}
}
``````

### Why This Is Better

- Controllers have a single, clean entrypoint.

- Internals remain testable and modular.

## Testing & Coverage
### Unit Tests
- BookSearchServiceTest
- SearchFacadeTest
- AvailabilityReportGeneratorTest

- OverdueReportGeneratorTest

- MembersReportGeneratorTest

- ReportRegistryTest

- MemberServiceTest

- LibraryServiceTest (Mockito)

### Integration Test
- ``LibraryFacadeIT`` with H2 in-memory database ```(jdbc:h2:mem:library)```

### Coverage
- #### Before: 62%
- #### After: 84%
- #### Verified in ``build/reports/jacoco/test/html/index.html``.

***Design Trade-offs***
- Kept legacy branches in LibraryService to avoid breaking original tests.

- Strategies are stateless.

- Registry and facade are thin and testable.

***Optional Next Steps***
- Real notification service with Spring Mail.

- Transaction management.

- REST controllers for facade.

- Observer pattern for waitlists.

- More report types to demonstrate OCP.

***Before vs After Highlights***
#### Report Generation Before

````
if ("overdue".equalsIgnoreCase(type)) { ... }
else if ("available".equalsIgnoreCase(type)) { ... }
````

**After**

````
return reportRegistry.get(type).generateReport();
````
**Search Before**
````
public List<Book> searchBooks(String term, String type) { ... if/else ... }
````
**After**
````
return searchFacade.search(term, type);
````

**Late Fees Before**

````
if (member.getMembershipType() == REGULAR) fee = days * 0.5;
else if (PREMIUM) fee = 0;
else if (STUDENT) fee = days * 0.25;
````

**After**
````
LateFeeCalculator calc = lateFeeCalculatorFactory.getCalculatorFor(member.getMembershipType());
double fee = calc.calculateLateFee(daysLate);
````

## How to Run
`````
./gradlew clean test jacocoTestReport
open build/reports/jacoco/test/html/index.html
`````

### H2 Console:

Run: ./gradlew bootRun -Dserver.port=8081

Visit: http://localhost:8081/h2-console

JDBC URL: jdbc:h2:mem:library, user sa, password empty

### Files Added / Touched
``edu.trincoll.service``
**Core Services**

- LibraryFacade

- BookSearchService

- SearchFacade

- MemberService

**Late Fee Strategy**

- LateFeeCalculator (interface)

- LateFeeCalculatorFactory

- RegularLateFeeCalculator

- PremiumLateFeeCalculator

- StudentLateFeeCalculator

- Reporting (Strategy + Registry)

- report/ReportGenerator (interface)

- report/AvailabilityReportGenerator

- report/OverdueReportGenerator

- report/MembersReportGenerator

- report/ReportRegistry

```src/test/java/edu/trincoll/service (Tests)```

- LibraryFacadeIT (Integration Test)

- LibraryServiceTest

- BookSearchServiceTest

- SearchFacadeTest

- MemberServiceTest

- AvailabilityReportGeneratorTest

- OverdueReportGeneratorTest

- MembersReportGeneratorTest

- ReportRegistryTest

## Summary
Lines changed: substantial (see git history)

New classes/interfaces: strategies, registry, facade, search services, tests

Hardest principle: OCP (finding the right seams for strategies without breaking tests)

Key learning: SRP + OCP + DIP + Strategy pattern + Facade = clean, extensible, testable design.
