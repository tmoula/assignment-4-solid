# Refactoring Report: SOLID Principles

**Project:** assignment-4-solid  
**Goal:** Move a monolithic `LibraryService` toward SOLID design with Spring Data JPA.  
**Result:** ✅ All tests passing, ✅ H2 integration test running, ✅ **80%+** service-layer coverage (from ~62%).

---

## Overview of What Changed

We decomposed the original `LibraryService` and introduced strategies, registries, and a facade. Final structure:

- `edu.trincoll.service`
    - `BookSearchService` ← focused search APIs
    - `SearchFacade` ← single entrypoint that routes to `BookSearchService`
    - `MemberService` ← member counters & lookups
    - `LateFeeCalculator` + `Regular/Premium/StudentLateFeeCalculator` + `LateFeeCalculatorFactory`
    - `report/`
        - `ReportGenerator` (interface)
        - `AvailabilityReportGenerator`, `OverdueReportGenerator`, `MembersReportGenerator`
        - `ReportRegistry` (type→strategy selector)
    - `LibraryService` (kept legacy behavior for compatibility)
    - `LibraryFacade` (simplified top-level API)

---

## Single Responsibility Principle (SRP)

### Violation
The original `LibraryService` had multiple responsibilities:
- Book operations (checkout/return)
- Member counters
- Notifications
- Search logic
- Report generation

### Our Solution
We extracted focused services:
- `BookSearchService` – handles searching
- `SearchFacade` – routes search requests
- `MemberService` – handles member state
- Report strategies – each handles one report type

### Code Example

**Before:**
```java
public List<Book> searchBooks(String searchTerm, String searchType) {
  if ("title".equalsIgnoreCase(searchType)) {
    return bookRepository.findByTitleContainingIgnoreCase(searchTerm);
  } else if ("author".equalsIgnoreCase(searchType)) {
    return bookRepository.findByAuthor(searchTerm);
  } else if ("isbn".equalsIgnoreCase(searchType)) {
    return bookRepository.findByIsbn(searchTerm).map(List::of).orElse(List.of());
  } else {
    throw new IllegalArgumentException("Invalid search type");
  }
}
```
**After:**
````
@Service
public class BookSearchService {
  private final BookRepository repo;
  public List<Book> searchByTitle(String t) { return repo.findByTitleContainingIgnoreCase(t); }
  public List<Book> searchByAuthor(String a) { return repo.findByAuthor(a); }
  public Optional<Book> searchByIsbn(String i) { return repo.findByIsbn(i); }
}

@Component
public class SearchFacade {
  private final BookSearchService svc;
  public List<Book> search(String term, String type) {
    if (type == null) throw new IllegalArgumentException("Invalid search type");
    return switch (type.toLowerCase()) {
      case "title"  -> svc.searchByTitle(term);
      case "author" -> svc.searchByAuthor(term);
      case "isbn"   -> svc.searchByIsbn(term).map(List::of).orElse(List.of());
      default       -> throw new IllegalArgumentException("Invalid search type");
    };
  }
}
````

### Why This Is Better

- One reason to change per class.

- Easier to mock and test.

- LibraryService delegates without complex branching.

- Open–Closed Principle (OCP) & Liskov Substitution Principle (LSP)
 
- Violation LibraryService.generateReport() used if/else blocks to handle each report type. Adding a new type required editing this method.

### Our Solution

We introduced a Strategy pattern with a Registry:

- ReportGenerator interface

- AvailabilityReportGenerator, OverdueReportGenerator, MembersReportGenerator

- ReportRegistry for selecting the right generator

**Before:**
````
public String generateReport(String reportType) {
  if ("overdue".equalsIgnoreCase(reportType)) { ... }
  else if ("available".equalsIgnoreCase(reportType)) { ... }
  else if ("members".equalsIgnoreCase(reportType)) { ... }
  else throw new IllegalArgumentException("Invalid report type");
}
````
**After**:

````
package edu.trincoll.service.report;

import org.springframework.stereotype.Component;

import java.util.Map;
import java.util.stream.Collectors;

@Component
public class ReportRegistry {
    private final Map<String, ReportGenerator> byType;

    public ReportRegistry(java.util.List<ReportGenerator> generators) {
        this.byType = generators.stream()
                .collect(Collectors.toMap(g -> g.getType().toLowerCase(), g -> g));
    }

    public ReportGenerator get(String type) {
        ReportGenerator gen = byType.get(type.toLowerCase());
        if (gen == null) throw new IllegalArgumentException("Invalid report type");
        return gen;
    }
}


````

### Why This Is Better

- OCP: add new reports by creating a class, not modifying existing code.

- LSP: all generators are interchangeable via ReportGenerator.

- Interface Segregation Principle (ISP) Violation  LibraryService forced clients to depend on unused methods.

### Our Solution
- Introduced SearchFacade so clients can depend only on what they need.

- LibraryFacade provides a simple entrypoint for controllers.

### Why This Is Better

- Smaller contracts.

- Clean mocking.

- Looser coupling.

- Dependency Inversion Principle (DIP)

### Violation
- High-level logic depended on concrete details (e.g., System.out.println for notifications, hard-coded branches).

### Our Solution
 - Depend on interfaces (ReportGenerator, LateFeeCalculator).
 - Use constructor injection.
 - ReportRegistry and LateFeeCalculatorFactory provide abstraction for selection. 

### Why This Is Better

- Easier to extend and test.
- Cleaner architecture.

### Strategy Pattern for Late Fees
We added:

- LateFeeCalculator interface

- RegularLateFeeCalculator, PremiumLateFeeCalculator, StudentLateFeeCalculator

- LateFeeCalculatorFactory to select the right strategy.

- This eliminated hard-coded if/else membership logic.

### Facade Pattern
``````
@Service
public class LibraryFacade {
  private final SearchFacade searchFacade;
  private final LibraryService libraryService;

  public List<Book> search(String term, String type) {
    return searchFacade.search(term, type);
  }

  public String generateReport(String type) {
    return libraryService.generateReport(type);
  }
}
``````

### Why This Is Better

- Controllers have a single, clean entrypoint.

- Internals remain testable and modular.

## Testing & Coverage
### Unit Tests
- BookSearchServiceTest
- SearchFacadeTest
- AvailabilityReportGeneratorTest

- OverdueReportGeneratorTest

- MembersReportGeneratorTest

- ReportRegistryTest

- MemberServiceTest

- LibraryServiceTest (Mockito)

### Integration Test
- ``LibraryFacadeIT`` with H2 in-memory database ```(jdbc:h2:mem:library)```

### Coverage 
- #### Before: 62%
- #### After: 84%
- #### Verified in ``build/reports/jacoco/test/html/index.html``.

***Design Trade-offs***
- Kept legacy branches in LibraryService to avoid breaking original tests.

- Strategies are stateless.

- Registry and facade are thin and testable.

***Optional Next Steps***
- Real notification service with Spring Mail.

- Transaction management.

- REST controllers for facade.

- Observer pattern for waitlists.

- More report types to demonstrate OCP.

***Before vs After Highlights***
#### Report Generation Before

````
if ("overdue".equalsIgnoreCase(type)) { ... }
else if ("available".equalsIgnoreCase(type)) { ... }
````

**After**

````
return reportRegistry.get(type).generateReport();
````
**Search Before**
````
public List<Book> searchBooks(String term, String type) { ... if/else ... }
````
**After**
````
return searchFacade.search(term, type);
````

**Late Fees Before**

````
if (member.getMembershipType() == REGULAR) fee = days * 0.5;
else if (PREMIUM) fee = 0;
else if (STUDENT) fee = days * 0.25;
````

**After**
````
LateFeeCalculator calc = lateFeeCalculatorFactory.getCalculatorFor(member.getMembershipType());
double fee = calc.calculateLateFee(daysLate);
````

## How to Run
`````
./gradlew clean test jacocoTestReport
open build/reports/jacoco/test/html/index.html
`````

### H2 Console:

Run: ./gradlew bootRun -Dserver.port=8081

Visit: http://localhost:8081/h2-console

JDBC URL: jdbc:h2:mem:library, user sa, password empty

### Files Added / Touched
``edu.trincoll.service``
**Core Services** 

- LibraryFacade

- BookSearchService

- SearchFacade

- MemberService

**Late Fee Strategy**

- LateFeeCalculator (interface)

- LateFeeCalculatorFactory

- RegularLateFeeCalculator

- PremiumLateFeeCalculator

- StudentLateFeeCalculator

- Reporting (Strategy + Registry)

- report/ReportGenerator (interface)

- report/AvailabilityReportGenerator

- report/OverdueReportGenerator

- report/MembersReportGenerator

- report/ReportRegistry

```src/test/java/edu/trincoll/service (Tests)```

- LibraryFacadeIT (Integration Test)

- LibraryServiceTest

- BookSearchServiceTest

- SearchFacadeTest

- MemberServiceTest

- AvailabilityReportGeneratorTest

- OverdueReportGeneratorTest

- MembersReportGeneratorTest

- ReportRegistryTest

## Summary
Lines changed: substantial (see git history)

New classes/interfaces: strategies, registry, facade, search services, tests

Hardest principle: OCP (finding the right seams for strategies without breaking tests)

Key learning: SRP + OCP + DIP + Strategy pattern + Facade = clean, extensible, testable design.